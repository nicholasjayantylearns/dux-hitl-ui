# BDD Dashboard Data Flow

This document describes the complete data flow from BDD feature files to the rendered dashboard UI.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         DATA FLOW PIPELINE                               │
└─────────────────────────────────────────────────────────────────────────┘

Step 1: Source Files (.feature)
    ↓
    ../features/*.feature (Gherkin BDD specifications)
    • workspace_ownership.feature
    • billing_tracking.feature
    • gitops_deployment.feature
    • etc.

Step 2: Parser (lib/gherkinParser.ts)
    ↓
    parseFeatureDirectory() → reads all .feature files
    • Uses @cucumber/gherkin to parse Gherkin syntax
    • Extracts: features, scenarios, steps, tags
    • Generates unique IDs (S1, S2, S3...)
    • Attempts to extract JTBD/target/current from comments

Step 3: Test Results Merge (optional)
    ↓
    public/bdd-data/behave-results.json (if exists)
    • mergeWithTestResults() updates step statuses
    • Maps behave status → parsed status
    • Calculates scenario/feature status from steps

Step 4: API Route (app/api/bdd/features/route.ts)
    ↓
    GET /api/bdd/features
    • Calls parseFeatureDirectory(getFeatureFilesPath())
    • Merges with behave results if available
    • Converts to API format (convertToAPIFormat)
    • Returns JSON response with all features

Step 5: Client-Side Fetch (app/feature-detail/[featureId]/page.tsx)
    ↓
    useEffect(() => fetch('/api/bdd/features'))
    • Fetches all features from API
    • Filters by featureId URL parameter
    • Stores in React state

Step 6: UI Rendering
    ↓
    React Components
    • DashboardHeader (JTBD + metrics)
    • UniversalCard (scenarios as cards)
    • Navigation buttons (Previous/Next)
```

## Detailed Component Breakdown

### 1. Source: BDD Feature Files

**Location:** `../features/*.feature` (one directory up from dashboard)

**Format:** Gherkin syntax
```gherkin
Feature: Get Started on New ML Project Quickly
  # JTBD: "When I need to launch a new ML project..."
  # Target: <5 minutes from request to running workspace

  Scenario: Data scientist launches workspace in under 5 minutes
    Given Sarah needs to analyze fraud patterns
    When she requests a new workspace "fraud-detection-team"
    Then the workspace reaches 'Ready' state within 5 minutes
```

**Key Elements:**
- Feature name (displayed as page title)
- JTBD comment (Jobs To Be Done - shown in header)
- Target/Current metrics (shown in dashboard header)
- Scenarios (displayed as cards)
- Steps (shown when card expanded)

---

### 2. Parser: lib/gherkinParser.ts

**Exports:**
- `parseFeatureFile(filePath: string): ParsedFeature | null`
- `parseFeatureDirectory(directory: string): ParsedFeature[]`
- `mergeWithTestResults(features, behaveResultsPath): ParsedFeature[]`
- `getFeatureFilesPath(): string` - resolves to `../features/`
- `getBehaveResultsPath(): string` - resolves to `public/bdd-data/behave-results.json`

**ParsedFeature Interface:**
```typescript
{
  id: string           // e.g., "workspace_ownership" (from filename)
  name: string         // Feature name from Gherkin
  description?: string // Feature description
  jtbd?: string        // Extracted from "# JTBD:" comment
  target?: string      // Extracted from "# Target:" comment
  currentState?: string // Extracted from "# Current:" comment
  scenarios: ParsedScenario[]
  status: 'passed' | 'failed' | 'undefined' | 'skipped' | 'pending'
  tags: string[]       // @tags from feature file
}
```

**Scenario ID Generation:**
- Scenarios numbered sequentially: S1, S2, S3, S4...
- Steps numbered within scenario: S1-step-1, S1-step-2, etc.

**Status Calculation:**
- Feature status = worst scenario status (failed > undefined > pending > passed)
- Scenario status = worst step status
- Default status = 'undefined' (when no test results available)

---

### 3. Test Results: public/bdd-data/behave-results.json

**Generated by:** `behave --format json > public/bdd-data/behave-results.json`

**Structure:**
```json
[
  {
    "name": "Feature name",
    "elements": [
      {
        "name": "Scenario name",
        "steps": [
          {
            "keyword": "Given",
            "name": "step text",
            "result": {
              "status": "passed"
            }
          }
        ]
      }
    ]
  }
]
```

**Merge Logic:**
1. Match feature by name
2. Match scenario by name
3. Match step by keyword + text
4. Update step.status from behave result
5. Recalculate scenario/feature status

---

### 4. API Route: app/api/bdd/features/route.ts

**Endpoint:** `GET /api/bdd/features`

**Process:**
```typescript
1. Get features path: getFeatureFilesPath()
   → ../features/ (relative to dashboard)

2. Parse all .feature files:
   parseFeatureDirectory(featuresPath)
   → Returns ParsedFeature[]

3. Merge with test results (if exists):
   mergeWithTestResults(parsedFeatures, behaveResultsPath)
   → Updates statuses

4. Convert to API format:
   features.map(convertToAPIFormat)
   → Converts statuses, adds calculated fields

5. Return JSON response:
   {
     features: BDDFeature[],
     summary: { total_features, total_scenarios, total_steps },
     generated_at: ISO timestamp,
     data_source: "Parsed from .feature files"
   }
```

**Status Conversion:**
- 'undefined' → 'not_started'
- 'pending' → 'in_progress'
- 'passed' → 'completed'
- 'failed' → 'failed'

**BDDFeature Interface:**
```typescript
{
  id: string
  name: string
  title: string
  file_path: string
  status: 'completed' | 'in_progress' | 'not_started' | 'failed'
  overall_progress: number  // percentage
  scenarios: BDDScenario[]
  passedScenarios: number
  totalScenarios: number
  jtbd?: string
  target?: string
  currentState?: string
}
```

---

### 5. Client Page: app/feature-detail/[featureId]/page.tsx

**URL Pattern:** `/feature-detail/{featureId}`
- Example: `/feature-detail/workspace_ownership`

**Data Fetching:**
```typescript
useEffect(() => {
  fetch('/api/bdd/features')
    .then(res => res.json())
    .then(data => {
      setAllFeatures(data.features)
      const found = data.features.find(f => f.id === featureId)
      setFeature(found)
    })
}, [featureId])
```

**State Management:**
- `feature` - Current feature data
- `allFeatures` - All features (for navigation)
- `expandedScenarioId` - Which scenario card is expanded
- `loading` - Loading state
- `error` - Error message if fetch fails

**Conversion to Card Format:**
```typescript
scenarios.map(scenario => ({
  id: scenario.id,
  title: scenario.name,
  type: 'scenario',
  status: mapStatus(scenario.status),
  metrics: {
    signals: { completed, total },
    evidence: 0,
    percentage
  },
  steps: scenario.steps.map(step => ({
    step: step.name,
    status: step.status
  }))
}))
```

---

### 6. UI Components

**DashboardHeader** ([components/DashboardHeader.tsx](../components/DashboardHeader.tsx))
- Displays JTBD (Jobs To Be Done)
- Shows metrics: target, current, success rate, progress

**UniversalCard** ([components/UniversalCard.tsx](../components/UniversalCard.tsx))
- Renders scenario as collapsible card
- Shows status color (gray/cyan/green/red)
- Displays metrics (signals completed/total)
- Expandable to show steps

**Navigation Buttons**
- Previous/Next feature navigation
- Disabled when at first/last feature
- Shows truncated feature name in button text

---

## Data Flow Examples

### Example 1: Fresh Feature (No Test Results)

```
Input: features/workspace_ownership.feature
  Feature: Get Started on New ML Project Quickly
    Scenario: Data scientist launches workspace in under 5 minutes
      Given Sarah needs to analyze fraud patterns
      When she requests a new workspace "fraud-detection-team"
      Then the workspace reaches 'Ready' state within 5 minutes

Parser Output:
  {
    id: "workspace_ownership",
    name: "Get Started on New ML Project Quickly",
    scenarios: [
      {
        id: "S2",
        name: "Data scientist launches workspace in under 5 minutes",
        steps: [
          { id: "S2-step-1", keyword: "Given", text: "Sarah needs...", status: "undefined" },
          { id: "S2-step-2", keyword: "When", text: "she requests...", status: "undefined" },
          { id: "S2-step-3", keyword: "Then", text: "the workspace...", status: "undefined" }
        ],
        status: "undefined"
      }
    ],
    status: "undefined"
  }

API Response:
  {
    id: "workspace_ownership",
    name: "Get Started on New ML Project Quickly",
    status: "not_started",
    overall_progress: 0,
    scenarios: [...],
    totalScenarios: 4
  }

UI Rendering:
  - Header: "Get Started on New ML Project Quickly"
  - 4 scenario cards, all gray (NOT STARTED)
  - Each card shows "0/12 signals" (0 steps passed, 12 total)
```

### Example 2: With Test Results

```
Input: Same .feature file + behave-results.json
  [
    {
      "name": "Get Started on New ML Project Quickly",
      "elements": [
        {
          "name": "Data scientist launches workspace in under 5 minutes",
          "steps": [
            { "keyword": "Given", "name": "Sarah needs...", "result": { "status": "passed" } },
            { "keyword": "When", "name": "she requests...", "result": { "status": "passed" } },
            { "keyword": "Then", "name": "the workspace...", "result": { "status": "failed" } }
          ]
        }
      ]
    }
  ]

After Merge:
  scenarios[0].steps[0].status = "passed"
  scenarios[0].steps[1].status = "passed"
  scenarios[0].steps[2].status = "failed"
  scenarios[0].status = "failed" (worst step status)
  feature.status = "failed"

API Response:
  status: "failed",
  overall_progress: 0  (0 scenarios fully passed)

UI Rendering:
  - Scenario card shows RED (FAILING)
  - Metrics show "2/3 signals" (2 passed steps, 3 total)
  - Percentage: 66%
  - Steps show:
    ✓ Given Sarah needs... (green)
    ✓ When she requests... (green)
    ✗ Then the workspace... (red)
```

---

## Navigation Flow

### URL-Based Feature Selection

```
User visits: /feature-detail/workspace_ownership

1. Page component receives params.featureId = "workspace_ownership"
2. Fetches all features from API
3. Finds feature where id === "workspace_ownership"
4. Renders that feature's scenarios

Navigation buttons:
- Previous: /feature-detail/billing_tracking (previous in array)
- Next: /feature-detail/gitops_deployment (next in array)
```

### Navigation State

```typescript
allFeatures = [
  { id: "billing_tracking", ... },
  { id: "workspace_ownership", ... },  // currentIndex = 1
  { id: "gitops_deployment", ... }
]

currentIndex = 1
hasPrevious = true  (index > 0)
hasNext = true      (index < 2)

onClick Previous → router.push('/feature-detail/billing_tracking')
onClick Next → router.push('/feature-detail/gitops_deployment')
```

---

## File Locations Reference

| Component | Path | Purpose |
|-----------|------|---------|
| **Feature Files** | `../features/*.feature` | BDD source files (Gherkin) |
| **Parser Library** | `lib/gherkinParser.ts` | Parse .feature files |
| **API Route** | `app/api/bdd/features/route.ts` | REST API endpoint |
| **Page Component** | `app/feature-detail/[featureId]/page.tsx` | Dynamic feature page |
| **Dashboard Header** | `components/DashboardHeader.tsx` | JTBD + metrics display |
| **Universal Card** | `components/UniversalCard.tsx` | Scenario card component |
| **Test Results** | `public/bdd-data/behave-results.json` | Behave test output (optional) |

---

## Debugging Tips

### API Not Returning Data?
```bash
# Test API directly
curl http://localhost:3002/api/bdd/features | jq '.features[] | {id, name}'

# Check features directory exists
ls -la ../features/*.feature

# Verify parser can read files
node -e "const parser = require('./lib/gherkinParser'); console.log(parser.getFeatureFilesPath())"
```

### Parser Errors?
```bash
# Check Gherkin syntax
npx gherkin-lint ../features/*.feature

# Manually parse single file
node -e "const parser = require('./lib/gherkinParser'); console.log(JSON.stringify(parser.parseFeatureFile('../features/workspace_ownership.feature'), null, 2))"
```

### Page Not Loading?
- Check browser console for fetch errors
- Verify API is running (Next.js dev server)
- Check featureId in URL matches actual feature ID
- Inspect Network tab in DevTools for API response

### Test Results Not Merging?
```bash
# Check behave-results.json exists and is valid JSON
cat public/bdd-data/behave-results.json | jq '.'

# Verify feature/scenario names match exactly
jq '.[] | {feature: .name, scenarios: [.elements[].name]}' public/bdd-data/behave-results.json
```

---

## Performance Considerations

**Parser Caching:**
- Currently parses on every API request
- Future: Cache parsed results, invalidate on file change
- Use file watcher to detect .feature file modifications

**API Response Size:**
- Current: Returns all features in single response
- Future: Add pagination or feature-specific endpoint (`/api/bdd/features/workspace_ownership`)

**Client-Side Fetching:**
- Current: Fetches all features, filters client-side
- Acceptable for <20 features
- Future: Server-side filtering for large feature sets

---

## Future Enhancements

1. **Real-time Updates:** WebSocket connection to push test result updates
2. **Feature-Specific API:** `/api/bdd/features/[id]` for single-feature requests
3. **JTBD Extraction:** Improve parser to reliably extract JTBD from comments
4. **Test Result Streaming:** Live behave test execution with SSE (Server-Sent Events)
5. **Caching Layer:** Redis cache for parsed features, invalidate on file change
6. **Search/Filter:** Full-text search across features/scenarios/steps
